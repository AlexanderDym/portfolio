// ========= КОНФИГ ВСЕХ КЕЙСОВ =========

const CASES = [
  {
    id: "icon-cyprus",
    shortTitle: "I-CON Cyprus",
    title: "I-CON на Кипре<br>Brand Experience Design",
    intro:
      "Нужно было создать яркую, лёгкую и коллекционную визуальную айдентику, которая бы ощущалась как летний бренд, а не корпоративный стенд.",
    theme: {
      bg: "#000000",
      accent: "#2f80ff",
    },
    images: [
      "images/case_1/Image_here.webp",
      "images/case_1/Image_here-1.webp",
      "images/case_1/Image_here-2.webp",
      "images/case_1/Image_here-3.webp",
      "images/case_1/Image_here-4.webp",
      "images/case_1/Image_here-5.webp",
      "images/case_1/Image_here-6.webp",
      "images/case_1/Image_here-7.webp",
      "images/case_1/Image_here-8.webp",
      "images/case_1/Image_here-9.webp",
    ],
    textBlocks: [
      {
        title: "Проблема 1/2",
        paragraphs: [
          "Для двух летних аффилиатных конференций нужно было создать мерч, который выделит бренд среди десятков стендов и будет выглядеть как стильная коллекция, а не корпоративные раздатки. Важно было передать летнее настроение и привлечь внимание аудитории.",
        ],
      },

      {
        title: "Проблема 2/2",
        paragraphs: [
          "Классические промо-наборы не создают вовлечения. Требовался мерч, который люди захотят носить, фотографировать и обсуждать. Нужен был летний образ — лёгкий, коллекционный и запоминающийся, чтобы включить “сарафанное радио” на конференциях.",
        ],
      },

      {
        title: "Решение 1/3",
        paragraphs: [
          "Я разработал визуальную концепцию коллекционного мерча для Кипра и Севильи: футболки, кепки и сумки с яркими летними принтами. Мягкие оттенки, солнечная графика и курортная эстетика создали лёгкое настроение и ощущение сезонной коллекции.",
        ],
      },

      {
        title: "Решение 2/3",
        paragraphs: [
          "Полностью взял на себя производство: поиск поставщиков, выбор тканей и плотности, подбор кроя, тестовые образцы и контроль качества печати. Каждый предмет я лично проверял — от материалов до финального цвета и тактильного ощущения.",
        ],
      },

      {
        title: "Решение 3/3",
        paragraphs: [
          "Чтобы усилить узнаваемость бренда, я применил принципы fashion-подхода, а не корпоративного дизайна. Мерч выглядел как предмет из летнего клуба и стал частью общего storytelling: коллекционные цвета, пляжная атмосфера и дружественный визуальный стиль.",
        ],
      },

      {
        title: "Результат 1/2",
        paragraphs: [
          "Мерч стал заметным элементом обоих событий: участники активно носили футболки и кепки, фотографировались и делились ими в соцсетях. Бренд выделился среди стендов, а стиль коллекции создал живую летнюю атмосферу вокруг команды.",
        ],
      },

      {
        title: "Результат 2/2",
        paragraphs: [
          "Футболки и кепки расходились в первые часы. Мерч стал точкой притяжения возле стенда, усилил коммуникацию и запустил сарафанное радио. Коллекция полностью справилась с задачей — повысила узнаваемость и сформировала позитивный образ бренда.",
        ],
      },
    ],
  },

  {
    id: "second-project",
    shortTitle: "Second Project",
    title: "Второй кейс<br>Creative Direction & Design",
    intro:
      "Заглушка для второго проекта. Здесь будет описание другого кейса: например, Tesla для такси, AI Dating или UCLIQ.",
    theme: {
      bg: "#000000",
      accent: "#ff8a00",
    },
    images: [
      "images/case_2/second-1.webp",
      "images/case_2/second-2.webp",
      "images/case_2/second-3.webp",
      "images/case_2/second-4.webp",
      // сюда при желании можно добавить видео:
      // { type: "video", src: "media/second-case.mp4", poster: "images/second-2.png" },
    ],
    textBlocks: [
      {
        title: "Проблема 1/2",
        paragraphs: [
          "Перед зимними праздниками нужно было придумать формат, который вовлечёт партнёров не просто постами, а полноценной игровой механикой. Требовалось создать цифровой опыт, который удержит внимание и станет частью праздничной атмосферы.",
          ,
        ],
      },

      {
        title: "Проблема 2/2",
        paragraphs: [
          "Простой рассылки оказалось недостаточно: важно было придумать механику, способную возвращать аудиторию каждый день. Нужен был инструмент, объединяющий участников, создающий азарт и поддерживающий интерес в течение недели.",
          ,
        ],
      },

      {
        title: "Решение 1/3",
        paragraphs: [
          "Я создал Telegram-квиз с ежедневными анонсами, напоминаниями и вопросами на время, где среди правильно ответивших бот случайно выбирал победителей дня, разыгрывая ограниченное количество призов.",
        ],
      },

      {
        title: "Решение 2/3",
        paragraphs: [
          "Я разработал механику, визуальный стиль, тексты и всю логику поведения бота. Он самостоятельно отправлял уведомления, запускал таймер, фиксировал ответы, исключал повторные попытки, собирал статистику и формировал списки победителей.",
        ],
      },

      {
        title: "Решение 3/3",
        paragraphs: [
          "Чтобы повысить интерес, я добавил систему случайных наград: подписки на Netflix, Amazon, YouTube, Spotify, бонусы и праздничный мерч. В финале бот выбрал трёх счастливчиков для розыгрыша главного приза — игровых консолей",
        ],
      },

      {
        title: "Результат 1/2",
        paragraphs: [
          "Проект длился 7 дней, и вовлечённость держалась стабильно высокой. Сотни участников ежедневно возвращались к квизу, соревновались за время ответа и ждали новые вопросы. Игровая механика превратила промо в настоящее событие.",
        ],
      },

      {
        title: "Результат 2/2",
        paragraphs: [
          "Система наград, таймеры и ежедневные вопросы создали сильный эмоциональный крючок. Проект получил отличный отклик, а созданная механика доказала, что интерактивный формат способен в разы повысить участие и удержание аудитории.",
        ],
      },
    ],
  },

  {
    id: "third-project",
    shortTitle: "Third Project",
    title: "3 кейс<br>Creative Direction & Design",
    intro:
      "Заглушка для второго проекта. Здесь будет описание другого кейса: например, Tesla для такси, AI Dating или UCLIQ.",
    theme: {
      bg: "#000000",
      accent: "#ff8a00",
    },
    images: [
      "images/case_3/prague_merch-1.webp",
      "images/case_3/prague_merch-2.webp",
      "images/case_3/prague_merch-3.webp",
      "images/case_3/prague_merch-4.webp",
      "images/case_3/prague_merch-5.webp",
      "images/case_3/prague_merch-6.webp",
      "images/case_3/prague_merch-7.webp",
      "images/case_3/prague_merch-8.webp",
      "images/case_3/prague_merch-9.webp",
      // сюда при желании можно добавить видео:
      // { type: "video", src: "media/second-case.mp4", poster: "images/second-2.png" },
    ],
    textBlocks: [
      {
        title: "Проблема 1/2",
        paragraphs: [
          "Перед зимними праздниками нужно было придумать формат, который вовлечёт партнёров не просто постами, а полноценной игровой механикой. Требовалось создать цифровой опыт, который удержит внимание и станет частью праздничной атмосферы.",
          ,
        ],
      },

      {
        title: "Проблема 2/2",
        paragraphs: [
          "Простой рассылки оказалось недостаточно: важно было придумать механику, способную возвращать аудиторию каждый день. Нужен был инструмент, объединяющий участников, создающий азарт и поддерживающий интерес в течение недели.",
          ,
        ],
      },

      {
        title: "Решение 1/3",
        paragraphs: [
          "Я создал Telegram-квиз с ежедневными анонсами, напоминаниями и вопросами на время, где среди правильно ответивших бот случайно выбирал победителей дня, разыгрывая ограниченное количество призов.",
        ],
      },

      {
        title: "Решение 2/3",
        paragraphs: [
          "Я разработал механику, визуальный стиль, тексты и всю логику поведения бота. Он самостоятельно отправлял уведомления, запускал таймер, фиксировал ответы, исключал повторные попытки, собирал статистику и формировал списки победителей.",
        ],
      },

      {
        title: "Решение 3/3",
        paragraphs: [
          "Чтобы повысить интерес, я добавил систему случайных наград: подписки на Netflix, Amazon, YouTube, Spotify, бонусы и праздничный мерч. В финале бот выбрал трёх счастливчиков для розыгрыша главного приза — игровых консолей",
        ],
      },

      {
        title: "Результат 1/2",
        paragraphs: [
          "Проект длился 7 дней, и вовлечённость держалась стабильно высокой. Сотни участников ежедневно возвращались к квизу, соревновались за время ответа и ждали новые вопросы. Игровая механика превратила промо в настоящее событие.",
        ],
      },

      {
        title: "Результат 2/2",
        paragraphs: [
          "Система наград, таймеры и ежедневные вопросы создали сильный эмоциональный крючок. Проект получил отличный отклик, а созданная механика доказала, что интерактивный формат способен в разы повысить участие и удержание аудитории.",
        ],
      },
    ],
  },

  {
    id: "fourth-project",
    shortTitle: "Fourth Project",
    title: "4 кейс<br>Creative Direction & Design",
    intro:
      "Заглушка для второго проекта. Здесь будет описание другого кейса: например, Tesla для такси, AI Dating или UCLIQ.",
    theme: {
      bg: "#000000",
      accent: "#ff8a00",
    },
    images: [
      "images/case_4/fourth-3.webp",
      "images/case_4/fourth-2.png",
      "images/case_4/fourth-1.png",

      // сюда при желании можно добавить видео:
      // { type: "video", src: "media/second-case.mp4", poster: "images/second-2.png" },
    ],
    textBlocks: [
      {
        title: "Проблема 1/2",
        paragraphs: [
          "Перед зимними праздниками нужно было придумать формат, который вовлечёт партнёров не просто постами, а полноценной игровой механикой. Требовалось создать цифровой опыт, который удержит внимание и станет частью праздничной атмосферы.",
          ,
        ],
      },

      {
        title: "Проблема 2/2",
        paragraphs: [
          "Простой рассылки оказалось недостаточно: важно было придумать механику, способную возвращать аудиторию каждый день. Нужен был инструмент, объединяющий участников, создающий азарт и поддерживающий интерес в течение недели.",
          ,
        ],
      },

      {
        title: "Решение 1/3",
        paragraphs: [
          "Я создал Telegram-квиз с ежедневными анонсами, напоминаниями и вопросами на время, где среди правильно ответивших бот случайно выбирал победителей дня, разыгрывая ограниченное количество призов.",
        ],
      },

      {
        title: "Решение 2/3",
        paragraphs: [
          "Я разработал механику, визуальный стиль, тексты и всю логику поведения бота. Он самостоятельно отправлял уведомления, запускал таймер, фиксировал ответы, исключал повторные попытки, собирал статистику и формировал списки победителей.",
        ],
      },

      {
        title: "Решение 3/3",
        paragraphs: [
          "Чтобы повысить интерес, я добавил систему случайных наград: подписки на Netflix, Amazon, YouTube, Spotify, бонусы и праздничный мерч. В финале бот выбрал трёх счастливчиков для розыгрыша главного приза — игровых консолей",
        ],
      },

      {
        title: "Результат 1/2",
        paragraphs: [
          "Проект длился 7 дней, и вовлечённость держалась стабильно высокой. Сотни участников ежедневно возвращались к квизу, соревновались за время ответа и ждали новые вопросы. Игровая механика превратила промо в настоящее событие.",
        ],
      },

      {
        title: "Результат 2/2",
        paragraphs: [
          "Система наград, таймеры и ежедневные вопросы создали сильный эмоциональный крючок. Проект получил отличный отклик, а созданная механика доказала, что интерактивный формат способен в разы повысить участие и удержание аудитории.",
        ],
      },
    ],
  },

  {
    id: "third-project",
    shortTitle: "Video Case",
    title: "Видео-кейс<br>Showreel",
    intro:
      "Кейс, в котором главное — видео. Вертикальный формат 9:16, как в Instagram Reels.",
    theme: {
      bg: "#000000",
      accent: "#ff8a00",
    },
    images: [
      {
        type: "video",
        src: "images/Fantacy_DC_pt3.mp4",
        // poster: "images/some-poster.png", // можешь добавить обложку
      },
    ],
    textBlocks: [
      {
        title: "Задача",
        paragraphs: [
          "Нужно было показать динамику и настроение бренда через короткий вертикальный ролик.",
        ],
      },
      {
        title: "Подход",
        paragraphs: [
          "Мы собрали showreel в формате 9:16, который хорошо смотрится на мобильных устройствах и в соцсетях.",
        ],
      },
      {
        title: "Результат",
        paragraphs: [
          "Видео использовалось в презентациях, на лендингах и в таргетированной рекламе.",
        ],
      },
    ],
  },

  {
    id: "third-project",
    shortTitle: "Video Case",
    title: "Видео-кейс<br>Showreel",
    intro:
      "Кейс, в котором главное — видео. Вертикальный формат 9:16, как в Instagram Reels.",
    theme: {
      bg: "#000000",
      accent: "#ff8a00",
    },
    images: [
      {
        type: "video",
        src: "images/Fantacy_DC_pt3.mp4",
        // poster: "images/some-poster.png", // можешь добавить обложку
      },
    ],
    textBlocks: [
      {
        title: "Задача",
        paragraphs: [
          "Нужно было показать динамику и настроение бренда через короткий вертикальный ролик.",
        ],
      },
      {
        title: "Подход",
        paragraphs: [
          "Мы собрали showreel в формате 9:16, который хорошо смотрится на мобильных устройствах и в соцсетях.",
        ],
      },
      {
        title: "Результат",
        paragraphs: [
          "Видео использовалось в презентациях, на лендингах и в таргетированной рекламе.",
        ],
      },
    ],
  },
];

const ABOUT_DATA = {
  title: "Creative Direction & Design",
  intro: "Немного о моём пути, подходе и том, что мне важно в работе.",
  theme: { bg: "#000000", accent: "#00c2ff" },
  images: [
    "images/about_me/1.webp",
    // добавь свои пути
  ],
  textBlocks: [
    {
      title: "Background",
      paragraphs: [
        "Немного о моём пути, подходе и том, что мне важно в работе",
      ],
    },
    {
      title: "What I do",
      paragraphs: [
        "Немного о моём пути, подходе и том, что мне важно в работе",
      ],
    },
    {
      title: "Values",
      paragraphs: [
        "Немного о моём пути, подходе и том, что мне важно в работе",
      ],
    },
  ],
};

function renderAbout() {
  // тема
  document.documentElement.style.setProperty("--bg-main", ABOUT_DATA.theme.bg);
  document.documentElement.style.setProperty(
    "--accent-blue",
    ABOUT_DATA.theme.accent
  );

  // заголовок + интро
  const titleEl = document.getElementById("case-title");
  const introEl = document.getElementById("case-intro");
  if (titleEl) titleEl.innerHTML = ABOUT_DATA.title;
  if (introEl) introEl.textContent = ABOUT_DATA.intro;

  // используем твою же логику слайдеров (images/text) как в renderCase
  const imageSliderEl = document.querySelector('[data-slider="images"]');
  const imageTrack = document.querySelector('[data-slider-track="images"]');
  const imageDots = document.querySelector('[data-slider-dots="images"]');
  const imagePrev = document.querySelector('[data-nav-zone="images-prev"]');
  const imageNext = document.querySelector('[data-nav-zone="images-next"]');

  if (imageSliderInstance && imageSliderInstance.destroy)
    imageSliderInstance.destroy();

  if (imageSliderEl && imageTrack && imageDots) {
    imageTrack.innerHTML = "";
    imageDots.innerHTML = "";

    const items = ABOUT_DATA.images.map((src) => ({ type: "image", src }));

    imageSliderInstance = createLoopSlider({
      sliderEl: imageSliderEl,
      trackEl: imageTrack,
      dotsEl: imageDots,
      items,
      buildSlide: (item) => {
        const slide = document.createElement("article");
        slide.className = "slider-slide slider-slide--image";
        const img = document.createElement("img");
        img.src = item.src;
        img.alt = "";
        img.className = "case-media case-media--image";
        slide.appendChild(img);
        return slide;
      },
      dotClass: "slider-dot",
      dotActiveClass: "slider-dot--active",
      onChange: null,
      arrowPrevEl: imagePrev,
      arrowNextEl: imageNext,
    });
  }

  const textSliderEl = document.querySelector('[data-slider="text"]');
  const textTrack = document.querySelector('[data-slider-track="text"]');
  const textDots = document.querySelector('[data-slider-dots="text"]');
  const textPrev = document.querySelector('[data-nav-zone="text-prev"]');
  const textNext = document.querySelector('[data-nav-zone="text-next"]');

  if (textSliderInstance && textSliderInstance.destroy)
    textSliderInstance.destroy();

  if (textSliderEl && textTrack && textDots) {
    textTrack.innerHTML = "";
    textDots.innerHTML = "";

    textSliderInstance = createLoopSlider({
      sliderEl: textSliderEl,
      trackEl: textTrack,
      dotsEl: textDots,
      items: ABOUT_DATA.textBlocks,
      buildSlide: (block) => {
        const card = document.createElement("article");
        card.className = "text-card";

        const header = document.createElement("header");
        header.className = "text-card-header";

        const dot = document.createElement("span");
        dot.className = "text-card-dot";

        const h = document.createElement("h2");
        h.className = "text-card-title";
        h.textContent = block.title;

        header.appendChild(dot);
        header.appendChild(h);

        const body = document.createElement("div");
        body.className = "text-card-body";

        block.paragraphs.forEach((t) => {
          const p = document.createElement("p");
          p.textContent = t;
          body.appendChild(p);
        });

        card.appendChild(header);
        card.appendChild(body);
        return card;
      },
      dotClass: "text-slider-dot",
      dotActiveClass: "text-slider-dot--active",
      onChange: null,
      arrowPrevEl: textPrev,
      arrowNextEl: textNext,
    });
  }

  triggerCaseFade();
}

// ========= ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ =========

let currentCaseIndex = 0;

let imageSliderInstance = null;
let textSliderInstance = null;
let projectsSliderInstance = null;

let activeSlider = null; // для управления стрелками клавиатуры

// ========= ИНИЦИАЛИЗАЦИЯ =========

document.addEventListener("DOMContentLoaded", () => {
  initParallax();

  const modal = document.querySelector(".intro-modal");
  const sureBtn = document.querySelector(".intro-button");

  if (modal && sureBtn) {
    const hasSeenModal = sessionStorage.getItem("hasSeenModal");

    if (!hasSeenModal) {
      modal.classList.add("modal--visible");

      sureBtn.addEventListener("click", () => {
        modal.classList.remove("modal--visible");
        modal.classList.add("modal--hidden");

        setTimeout(() => {
          modal.style.display = "none";
        }, 400);

        sessionStorage.setItem("hasSeenModal", "true");
      });
    } else {
      modal.style.display = "none";
    }
  }

  const storedCaseId = sessionStorage.getItem("activeCaseId");
  const bodyCaseId = document.body.dataset.caseId;

  const caseId = storedCaseId || bodyCaseId;
  const indexToRender = CASES.findIndex((c) => c.id === caseId);

  const isAboutPage = document.body.classList.contains("page--about");
  if (isAboutPage) {
    renderAbout();
    return;
  }

  renderCase(indexToRender >= 0 ? indexToRender : currentCaseIndex);

  if (storedCaseId) {
    sessionStorage.removeItem("activeCaseId");
  }

  // запускаем projectSlider на любой странице кейса, где он есть
  if (document.querySelector('[data-slider="projects"]')) {
    initProjectsSlider();
  }

  triggerCaseFade();

  document.addEventListener("keydown", (e) => {
    if (!activeSlider) return;
    if (e.key === "ArrowLeft") {
      e.preventDefault();
      activeSlider.prev && activeSlider.prev();
    } else if (e.key === "ArrowRight") {
      e.preventDefault();
      activeSlider.next && activeSlider.next();
    }
  });
});

// маленький хелпер: плавное появление кейса
function triggerCaseFade() {
  const caseEl = document.querySelector(".case");
  if (!caseEl) return;

  // сбрасываем состояние
  caseEl.classList.remove("case--visible");
  // форсим перерисовку, чтобы анимация заново проигрывалась
  void caseEl.offsetWidth;
  // включаем видимое состояние
  caseEl.classList.add("case--visible");
}

// ========= РЕНДЕР КЕЙСА =========

function renderCase(index) {
  const data = CASES[index];
  if (!data) return;

  currentCaseIndex = index;

  // фон / акцент
  document.documentElement.style.setProperty("--bg-main", data.theme.bg);
  document.documentElement.style.setProperty(
    "--accent-blue",
    data.theme.accent
  );

  // заголовок и интро
  const titleEl = document.getElementById("case-title");
  const introEl = document.getElementById("case-intro");

  if (titleEl) titleEl.innerHTML = data.title;
  if (introEl) introEl.textContent = data.intro;

  // ===== СЛАЙДЕР КАРТИНОК / ВИДЕО =====
  const imageSliderEl = document.querySelector('[data-slider="images"]');
  const imageTrack = document.querySelector('[data-slider-track="images"]');
  const imageDots = document.querySelector('[data-slider-dots="images"]');

  const imagePrev = document.querySelector('[data-nav-zone="images-prev"]');
  const imageNext = document.querySelector('[data-nav-zone="images-next"]');

  if (imageSliderInstance && imageSliderInstance.destroy) {
    imageSliderInstance.destroy();
  }

  if (imageSliderEl && imageTrack && imageDots) {
    imageTrack.innerHTML = "";
    imageDots.innerHTML = "";

    // нормализуем список: строка → { type: "image", src }
    const items = data.images.map((media) =>
      typeof media === "string" ? { type: "image", src: media } : media
    );

    imageSliderInstance = createLoopSlider({
      sliderEl: imageSliderEl,
      trackEl: imageTrack,
      dotsEl: imageDots,
      items,
      buildSlide: (item) => {
        const slide = document.createElement("article");
        slide.className = "slider-slide slider-slide--image";

        // ВИДЕО
        if (item.type === "video") {
          const video = document.createElement("video");
          video.src = item.src;
          video.controls = true;
          video.playsInline = true;
          video.preload = "metadata";
          video.className = "case-media case-media--video";
          slide.classList.add("slider-slide--video");

          if (item.poster) {
            video.poster = item.poster;
          }

          slide.appendChild(video);
          return slide;
        }

        // КАРТИНКА
        const img = document.createElement("img");
        img.src = item.src;
        img.alt = "";
        img.className = "case-media case-media--image";

        slide.appendChild(img);
        return slide;
      },
      dotClass: "slider-dot",
      dotActiveClass: "slider-dot--active",
      onChange: null,
      arrowPrevEl: imagePrev,
      arrowNextEl: imageNext,
    });
  }

  // ===== СЛАЙДЕР ТЕКСТА =====
  const textSliderEl = document.querySelector('[data-slider="text"]');
  const textTrack = document.querySelector('[data-slider-track="text"]');
  const textDots = document.querySelector('[data-slider-dots="text"]');

  const textPrev = document.querySelector('[data-nav-zone="text-prev"]');
  const textNext = document.querySelector('[data-nav-zone="text-next"]');

  if (textSliderInstance && textSliderInstance.destroy) {
    textSliderInstance.destroy();
  }

  if (textSliderEl && textTrack && textDots) {
    textTrack.innerHTML = "";
    textDots.innerHTML = "";

    const items = data.textBlocks;

    textSliderInstance = createLoopSlider({
      sliderEl: textSliderEl,
      trackEl: textTrack,
      dotsEl: textDots,
      items,
      buildSlide: (block) => {
        // ✅ обёртка-слайд 100% ширины
        const slide = document.createElement("div");
        slide.className = "text-slide";

        // ✅ внутренняя карточка со скруглением
        const card = document.createElement("article");
        card.className = "text-card";

        const header = document.createElement("header");
        header.className = "text-card-header";

        const dot = document.createElement("span");
        dot.className = "text-card-dot";

        const h = document.createElement("h2");
        h.className = "text-card-title";
        h.textContent = block.title;

        header.appendChild(dot);
        header.appendChild(h);

        const body = document.createElement("div");
        body.className = "text-card-body";

        block.paragraphs.forEach((t) => {
          const p = document.createElement("p");
          p.textContent = t;
          body.appendChild(p);
        });

        card.appendChild(header);
        card.appendChild(body);

        slide.appendChild(card);
        return slide;
      },

      dotClass: "text-slider-dot",
      dotActiveClass: "text-slider-dot--active",
      onChange: null,
      arrowPrevEl: textPrev,
      arrowNextEl: textNext,
    });
  }

  // обновляем выделение названия проекта (с перезапуском анимации)
  updateProjectPillsActiveState();
  triggerCaseFade();
}

// ========= ПРОЕКТНЫЙ СЛАЙДЕР (ВЕРХНИЙ) =========

function initProjectsSlider() {
  const sliderEl = document.querySelector('[data-slider="projects"]');
  const trackEl = document.querySelector('[data-slider-track="projects"]');
  const dotsEl = document.querySelector('[data-slider-dots="projects"]');

  const arrowPrevEl = document.querySelector('[data-nav-zone="projects-prev"]');
  const arrowNextEl = document.querySelector('[data-nav-zone="projects-next"]');

  if (!sliderEl || !trackEl || !dotsEl) return;

  trackEl.innerHTML = "";
  dotsEl.innerHTML = "";

  const items = CASES.map((c) => ({ label: c.shortTitle }));

  projectsSliderInstance = createLoopSlider({
    sliderEl,
    trackEl,
    dotsEl,
    items,
    startIndexReal: currentCaseIndex,
    buildSlide: (item, index) => {
      const slide = document.createElement("div");
      slide.className = "slider-slide slider-slide--project-name";

      const pill = document.createElement("span");
      pill.className =
        "project-pill" + (index === 0 ? " project-pill--active" : "");
      pill.textContent = item.label;

      slide.appendChild(pill);
      return slide;
    },
    dotClass: "slider-dot",
    dotActiveClass: "slider-dot--active",
    onChange: (realIndex) => {
      if (realIndex !== currentCaseIndex) {
        renderCase(realIndex);
      }
    },
    arrowPrevEl,
    arrowNextEl,
  });
}

function updateProjectPillsActiveState() {
  const pills = document.querySelectorAll(".project-pill");

  pills.forEach((pill, idx) => {
    if (idx === currentCaseIndex) {
      // снимаем класс, форсим перерисовку и снова добавляем
      pill.classList.remove("project-pill--active");
      void pill.offsetWidth; // сброс transition
      pill.classList.add("project-pill--active");
    } else {
      pill.classList.remove("project-pill--active");
    }
  });
}

// ========= УНИВЕРСАЛЬНЫЙ БЕСШОВНЫЙ СЛАЙДЕР =========

function createLoopSlider({
  sliderEl,
  trackEl,
  dotsEl,
  items,
  buildSlide,
  dotClass,
  dotActiveClass,
  onChange,
  arrowPrevEl,
  arrowNextEl,
  startIndexReal = 0,
}) {
  if (!items || items.length === 0) {
    return {
      prev() {},
      next() {},
      destroy() {},
    };
  }

  const realCount = items.length;

  // создаём реальные слайды
  const realSlides = items.map((item, i) => buildSlide(item, i));

  // очищаем трек
  trackEl.innerHTML = "";

  // клоны для бесшовной прокрутки
  const firstClone = buildSlide(items[0], 0);
  const lastClone = buildSlide(items[realCount - 1], realCount - 1);
  firstClone.dataset.clone = "true";
  lastClone.dataset.clone = "true";

  trackEl.appendChild(lastClone);
  realSlides.forEach((slide) => trackEl.appendChild(slide));
  trackEl.appendChild(firstClone);

  // точки
  dotsEl.innerHTML = "";
  const dots = [];
  for (let i = 0; i < realCount; i++) {
    const dot = document.createElement("span");
    dot.className = dotClass + (i === 0 ? ` ${dotActiveClass}` : "");
    dot.addEventListener("click", () => {
      goToSlide(i + 1, true);
    });
    dotsEl.appendChild(dot);
    dots.push(dot);
  }

  let currentIndex = Math.max(0, Math.min(realCount - 1, startIndexReal)) + 1;
  // индекс в allSlides (0..realCount+1)
  let isTransitioning = false;

  function setTransition(enable) {
    trackEl.style.transition = enable
      ? "transform 0.6s cubic-bezier(.34,0.6,.64,1)"
      : "none";
  }

  function applyTransform() {
    const offset = -currentIndex * 100;
    trackEl.style.transform = `translateX(${offset}%)`;
  }

  function getRealIndex() {
    if (currentIndex === 0) return realCount - 1;
    if (currentIndex === realCount + 1) return 0;
    return currentIndex - 1;
  }

  function isCurrentSlideVideo() {
    const realIndex = getRealIndex();
    const slide = realSlides[realIndex];
    return slide && slide.classList.contains("slider-slide--video");
  }

  function updateDots() {
    const realIndex = getRealIndex();
    dots.forEach((dot, idx) => {
      dot.classList.toggle(dotActiveClass, idx === realIndex);
    });
  }

  function goToSlide(index, animate) {
    if (isTransitioning && animate) return;
    currentIndex = index;
    setTransition(animate);
    applyTransform();
    updateDots();
  }

  function goNext() {
    goToSlide(currentIndex + 1, true);
  }

  function goPrev() {
    goToSlide(currentIndex - 1, true);
  }

  // transition события
  const onTransitionStart = () => {
    isTransitioning = true;
  };

  const onTransitionEnd = () => {
    isTransitioning = false;

    if (currentIndex === 0) {
      setTransition(false);
      currentIndex = realCount;
      applyTransform();
    } else if (currentIndex === realCount + 1) {
      setTransition(false);
      currentIndex = 1;
      applyTransform();
    }

    const realIndex = getRealIndex();
    if (typeof onChange === "function") {
      onChange(realIndex);
    }
  };

  trackEl.addEventListener("transitionstart", onTransitionStart);
  trackEl.addEventListener("transitionend", onTransitionEnd);

  // стрелки
  if (arrowPrevEl) {
    arrowPrevEl.addEventListener("click", (e) => {
      e.preventDefault();
      goPrev();
    });
  }

  if (arrowNextEl) {
    arrowNextEl.addEventListener("click", (e) => {
      e.preventDefault();
      goNext();
    });
  }

  // === TOUCH SWIPE (НОРМ ДЛЯ МОБИЛОК) ===
  let touchStartX = 0;
  let touchStartY = 0;
  let lastTouchX = 0;
  let lastTouchY = 0;
  let isTouching = false;
  let isHorizontalSwipe = false;
  const swipeThreshold = 30;

  const onTouchStart = (e) => {
    if (!e.touches || !e.touches[0]) return;

    // если текущий слайд — видео, свайп отключаем
    if (isCurrentSlideVideo()) return;

    const t = e.touches[0];
    isTouching = true;
    isHorizontalSwipe = false;
    touchStartX = t.clientX;
    touchStartY = t.clientY;
    lastTouchX = t.clientX;
    lastTouchY = t.clientY;
  };

  const onTouchMove = (e) => {
    if (!isTouching || !e.touches || !e.touches[0]) return;
    const t = e.touches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;

    if (!isHorizontalSwipe) {
      if (Math.abs(dx) > 8 && Math.abs(dx) > Math.abs(dy)) {
        isHorizontalSwipe = true;
      } else if (Math.abs(dy) > Math.abs(dx)) {
        isHorizontalSwipe = false;
        return;
      }
    }

    if (isHorizontalSwipe) {
      e.preventDefault();
      lastTouchX = t.clientX;
      lastTouchY = t.clientY;
    }
  };

  const onTouchEnd = (e) => {
    if (!isTouching) return;
    isTouching = false;

    const t = (e.changedTouches && e.changedTouches[0]) || {
      clientX: lastTouchX,
      clientY: lastTouchY,
    };

    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;

    if (!isHorizontalSwipe) return;
    if (Math.abs(dx) < swipeThreshold || Math.abs(dx) < Math.abs(dy) * 0.5) {
      return;
    }

    if (dx > 0) {
      goPrev();
    } else {
      goNext();
    }
  };

  sliderEl.addEventListener("touchstart", onTouchStart, { passive: true });
  sliderEl.addEventListener("touchmove", onTouchMove, { passive: false });
  sliderEl.addEventListener("touchend", onTouchEnd, { passive: true });

  // mouse drag
  let isMouseDown = false;
  let mouseStartX = 0;
  let mouseStartY = 0;

  const onMouseDown = (e) => {
    if (e.button !== 0) return;

    // Отключаем drag при клике на видео (любой вложенный элемент внутри тега <video>)
    if (e.target.closest("video")) return;

    // если текущий слайд — видео, отключаем drag вообще
    if (isCurrentSlideVideo()) return;

    isMouseDown = true;
    mouseStartX = e.clientX;
    mouseStartY = e.clientY;
  };

  const onMouseUp = (e) => {
    if (!isMouseDown) return;
    isMouseDown = false;

    const dx = e.clientX - mouseStartX;
    const dy = e.clientY - mouseStartY;

    if (Math.abs(dy) > Math.abs(dx)) return;

    if (dx > 25) {
      goPrev();
    } else if (dx < -25) {
      goNext();
    }
  };

  trackEl.addEventListener("mousedown", onMouseDown);
  document.addEventListener("mouseup", onMouseUp);

  // wheel / тачпад
  let wheelLocked = false;
  const wheelThreshold = 20;
  const wheelLockTime = 250;

  const onWheel = (e) => {
    // если сейчас видео — не листаем тачпадом
    if (isCurrentSlideVideo()) return;

    if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) return;
    const dx = e.deltaX;
    if (Math.abs(dx) < wheelThreshold) return;
    if (wheelLocked) return;

    wheelLocked = true;
    if (dx > 0) {
      goNext();
    } else if (dx < 0) {
      goPrev();
    }

    setTimeout(() => {
      wheelLocked = false;
    }, wheelLockTime);
  };

  sliderEl.addEventListener("wheel", onWheel, { passive: true });

  // активный слайдер для клавиатуры
  const onMouseEnter = () => {
    activeSlider = api;
  };
  const onMouseLeave = () => {
    if (activeSlider === api) {
      activeSlider = null;
    }
  };

  sliderEl.addEventListener("mouseenter", onMouseEnter);
  sliderEl.addEventListener("mouseleave", onMouseLeave);

  // старт
  setTransition(false);
  applyTransform();
  updateDots();

  const api = {
    prev: goPrev,
    next: goNext,
    destroy() {
      trackEl.removeEventListener("transitionstart", onTransitionStart);
      trackEl.removeEventListener("transitionend", onTransitionEnd);
      sliderEl.removeEventListener("touchstart", onTouchStart);
      sliderEl.removeEventListener("touchmove", onTouchMove);
      sliderEl.removeEventListener("touchend", onTouchEnd);
      trackEl.removeEventListener("mousedown", onMouseDown);
      document.removeEventListener("mouseup", onMouseUp);
      sliderEl.removeEventListener("wheel", onWheel);
      sliderEl.removeEventListener("mouseenter", onMouseEnter);
      sliderEl.removeEventListener("mouseleave", onMouseLeave);
      if (activeSlider === api) {
        activeSlider = null;
      }
    },
  };

  return api;
}

// ========= ПАРАЛЛАКС =========

function initParallax() {
  const items = Array.from(document.querySelectorAll(".parallax-item"));
  if (items.length === 0) return;

  let ticking = false;

  function onScroll() {
    if (!ticking) {
      window.requestAnimationFrame(() => {
        updateParallax(items);
        ticking = false;
      });
      ticking = true;
    }
  }

  window.addEventListener("scroll", onScroll, { passive: true });
  window.addEventListener("resize", () => updateParallax(items));

  updateParallax(items);
}

function updateParallax(items) {
  const viewportHeight =
    window.innerHeight || document.documentElement.clientHeight;
  const maxShift = 16;

  items.forEach((el) => {
    const rect = el.getBoundingClientRect();
    const elCenter = rect.top + rect.height / 2;
    const viewportCenter = viewportHeight / 2;

    const rel = (elCenter - viewportCenter) / viewportHeight;
    const shift = -rel * maxShift;

    el.style.transform = `translateY(${shift}px)`;
  });
}
// ===============================
// WORKS GRID (Projects Overview)
// ===============================

document.addEventListener("DOMContentLoaded", () => {
  const gridEl = document.getElementById("worksGrid");
  if (!gridEl) return; // если не works.html — выходим

  renderWorksGrid(gridEl);
});

function renderWorksGrid(container) {
  // фильтруем: убираем About Me
  const workCases = CASES.filter((c) => c.id !== "about-me");

  container.innerHTML = "";

  workCases.forEach((project, index) => {
    const card = document.createElement("article");
    card.className = "work-card";

    // ---------- Media ----------
    const media = document.createElement("div");
    media.className = "work-card-media";

    const firstItem = project.images[0];

    // Видео
    if (typeof firstItem === "object" && firstItem.type === "video") {
      const video = document.createElement("video");
      video.src = firstItem.src;
      video.muted = true;
      video.loop = true;
      video.playsInline = true;
      video.preload = "metadata";

      media.appendChild(video);

      const badge = document.createElement("span");
      badge.className = "work-card-badge";
      badge.textContent = "Video";
      media.appendChild(badge);

      card.addEventListener("mouseenter", () => video.play());
      card.addEventListener("mouseleave", () => video.pause());
    }
    // Картинка
    else {
      const img = document.createElement("img");
      img.src = firstItem;
      img.alt = project.shortTitle || "";
      media.appendChild(img);
    }

    // ---------- Text ----------
    const title = document.createElement("h3");
    title.className = "work-card-title";
    title.textContent = project.shortTitle;

    const meta = document.createElement("p");
    meta.className = "work-card-meta";
    meta.textContent = extractProjectType(project.title);

    // ---------- Click ----------
    card.addEventListener("click", () => {
      openCase(project.id);
    });

    card.appendChild(media);
    card.appendChild(title);
    card.appendChild(meta);

    container.appendChild(card);
  });
}

// ===============================
// HELPERS
// ===============================

// определяем тип проекта из title
function extractProjectType(title = "") {
  const t = title.toLowerCase();

  if (t.includes("video")) return "Video / Showreel";
  if (t.includes("brand")) return "Brand Experience";
  if (t.includes("creative")) return "Creative Direction";
  if (t.includes("design")) return "Design";
  return "Creative Project";
}

// открытие кейса
function openCase(caseId) {
  sessionStorage.setItem("activeCaseId", caseId);
  window.location.href = "case.html";
}

// ===============================
// INTRO MODAL ACTIONS
// ===============================

document.addEventListener("DOMContentLoaded", () => {
  const btnWorks = document.getElementById("introWorks");
  const btnAbout = document.getElementById("introAbout");

  if (btnWorks) {
    btnWorks.addEventListener("click", () => {
      window.location.href = "works.html";
    });
  }

  if (btnAbout) {
    btnAbout.addEventListener("click", () => {
      window.location.href = "about.html";
    });
  }
});
